# Lesson 3 - Anatomy { Engine & Evaluation }

## Intro

We've tokenized our source code into tokens, and parsed those tokens into an Abstract Syntax Tree (AST). But so far, nothing has actually *happened*. The code hasn't executed. That's where the engine comes in!

The engine is the heart of SIMPL - it's what brings the code to life. It takes the AST and evaluates it, executing your program step by step. The engine manages:

- **The Stack** - Where temporary values and return addresses are stored
- **Scopes** - Variable visibility and lifetime management  
- **The Call Stack** - Tracks function calls and returns
- **Type System** - Manages custom objects and types
- **Built-in Functions** - Provides core functionality

Think of the engine as a virtual machine that runs your SIMPL code. It walks through the AST, interpreting each statement and expression, updating variables, calling functions, and producing results.

## How Evaluation Works

When you call `simpl::evaluate(ast, engine)`, the engine:

1. Iterates through each statement in the AST
2. For each statement, determines what type it is (let, if, while, function call, etc.)
3. Executes the appropriate logic for that statement type
4. Manages the stack and scopes as needed
5. Continues until all statements are evaluated

For example, when evaluating a let statement:
```simpl
let x = 5 + 3;
```

The engine:
1. Evaluates the expression `5 + 3` (pushes 5 and 3 on the stack, performs addition)
2. Creates a new variable `x` in the current scope
3. Assigns the result (8) to that variable

## The Stack and Scopes

SIMPL uses a stack-based execution model. Values are pushed onto and popped from a stack as the program executes. Each function call creates a new scope, which is like a container for local variables.

```simpl
def outer() {
    let x = 10;  # x is in outer's scope
    inner();
}

def inner() {
    let y = 20;  # y is in inner's scope
    # x is not accessible here (different scope)
}
```

When `inner()` is called from `outer()`:
1. A new scope is created for `inner`
2. The call stack tracks that we're in `inner`, called from `outer`
3. When `inner` returns, its scope is destroyed
4. Control returns to `outer`

## Exercise 3 - Testing the Engine

Review the code in the file `simpl.test/simpl.engine.test.cpp`.

The engine tests are different from tokenizer and parser tests. They actually *execute* SIMPL code and verify the results. Many tests use special test functions like `dbg_break()` and `assert()` that are registered just for testing.

## Your Contribution: Add an Engine Test for Variables

Now it's your turn to write an engine test that verifies variable assignment and arithmetic operations work correctly.

### Task: Test Variable Arithmetic

Write a test that:
1. Declares a variable with an initial value
2. Performs arithmetic on it
3. Verifies the final value is correct

**Add this test to `simpl.test/simpl.engine.test.cpp`:**

Find the `simpl_engine_test` class and add this new test method:

```cpp
TEST_METHOD(TestVariableArithmetic)
{
    bool called = false;
    check = [&](const simpl::value_t& v)
    {
        called = true;
        Assert::IsTrue(std::holds_alternative<simpl::number>(v));
        Assert::AreEqual(15.0, std::get<simpl::number>(v));
    };
    
    auto ast = simpl::parse("let x = 10; x = x + 5; assert(x);");
    simpl::evaluate(ast, e);
    Assert::IsTrue(called);
}
```

**What this test does:**
- Creates a variable `x` with value 10
- Adds 5 to it (making it 15)
- Uses the `assert()` test function to check the value
- The `check` lambda verifies the value is 15

### Understanding the Test Pattern

Engine tests often use this pattern:
1. Set up a `check` or `trap` lambda to capture execution state
2. Parse and evaluate SIMPL code
3. The lambda runs when a special test function is called
4. Assertions in the lambda verify the expected behavior

### Bonus Challenges

Try implementing these additional tests:

**Test String Concatenation:**
```cpp
TEST_METHOD(TestStringConcatenation)
{
    bool called = false;
    check = [&](const simpl::value_t& v)
    {
        called = true;
        Assert::IsTrue(std::holds_alternative<std::string>(v));
        Assert::AreEqual(std::string("Hello World"), std::get<std::string>(v));
    };
    
    auto ast = simpl::parse("let greeting = \"Hello\"; greeting = greeting + \" World\"; assert(greeting);");
    simpl::evaluate(ast, e);
    Assert::IsTrue(called);
}
```

**Test Function Return Values:**
```cpp
TEST_METHOD(TestFunctionReturnValue)
{
    bool called = false;
    check = [&](const simpl::value_t& v)
    {
        called = true;
        Assert::IsTrue(std::holds_alternative<simpl::number>(v));
        Assert::AreEqual(42.0, std::get<simpl::number>(v));
    };
    
    auto ast = simpl::parse("def get_answer() { return 42; } let answer = get_answer(); assert(answer);");
    simpl::evaluate(ast, e);
    Assert::IsTrue(called);
}
```

### Running Your Tests

1. Build the `simpl.test` project
2. Open Test Explorer (Test -> Test Explorer)
3. Find your new test and run it
4. If it fails, use the debugger to step through the code

### Commit Your Work

```bash
git add simpl.test/simpl.engine.test.cpp
git commit -m "Add engine tests for variable arithmetic and operations"
```

## Understanding Value Types

SIMPL uses `std::variant` to represent values. The `value_t` type can hold:
- `simpl::number` - Numeric values (double)
- `std::string` - String values
- `simpl::array` - Arrays
- `simpl::object` - Custom objects
- `simpl::function` - Functions

Use `std::holds_alternative<T>()` to check the type and `std::get<T>()` to extract the value.

Excellent work! You've now tested all three major components of the SIMPL language pipeline: tokenizer, parser, and engine!

## Next
[Lesson 4](https://github.com/mvpete/simpl/blob/master/lessons/L4.md)
