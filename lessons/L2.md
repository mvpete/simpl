# Lesson 2 - Anatomy { Parser }

## Intro
At this point we've converted the source code into a stream of tokens. The next part is to add some context to the stream,
this is done in the parser. The parsers responsibility is to iterate the stream of tokens looking for specific sequences of 
tokens that mean something. In SIMPL, each meaningful collection of tokens is called a `statement`. A statement is holds enough
information to be acted on by a component outside of the parser. In our case, this is our execution engine, but could equally be
some type of optimizer or a different backend.

Unlike tokenizing, parsing means that we need to add meaning to what the statements are representing. A statement in SIMPL is
made up of a collection of statements, or expressions.

*Note* I didn't write a formal grammar for this language. I kind of just made things up as I went. But it's basically, an expression is made of characters, a statement is an expression started with a keyword, then something, terminated by a ';', or a '}' when it's a block of expressions.

Take for instance the following let statement

`let foo = new ["hello", "world"];`

A let statement (variable declaration) consists of the let keyword, an identifier, and an expression. The expression 
is something that can be evaluated itself. In this case the expression is a `new array` expression, which houses two value 
expressions, hello and world.

An assignment is an expression, when done like below, it is considered an expression statement.

`foo[0] = "goodbye";`

It consists of an identifer expression, an operator, and the value expression "goodbye";

These types of structure are called "Abstract Syntax Trees", they're syntactical representations of the code that you wrote, that define the structure of the program. This is the job of the parser, it takes your lexical syntax i.e. code, and turns it into a programmatic representation of that code. At this point, there's no behaviour associated with it which is why it's "abstract".

The parser works with the tokenizer to consume tokens and ensure the tokens are in the correct structure for the given statement. The parser uses the tokenizer's `peek` function to "look ahead" at the next token. This allows the parser to decide which branch to take when there is ambiguity.


## Exercise 2 - Testing the Parser

Review the code in the file `simpl.test/simpl.parser.test.cpp`.

Again - if you're this far you're already familiar with the toolchain. You can see the parser tests, they are intended 
to verify the generated Abstract Syntax Tree.

## Your Contribution: Add a New Parser Test

Now it's your turn to write a parser test! The parser tests verify that SIMPL code is correctly transformed into an Abstract Syntax Tree (AST). 

### Task: Test Function Definition Parsing

SIMPL supports function definitions using the `def` keyword. Let's add a test to verify that function definitions are parsed correctly.

**Function definition syntax in SIMPL:**
```simpl
def function_name(param1, param2) {
    # function body
    return value;
}
```

### Your Implementation Task

1. Open `simpl.test/simpl.parser.test.cpp`
2. Add a new test method to test function definition parsing
3. Follow the pattern from existing tests

**Add this test method to the `simpl_parser_test` class:**

```cpp
TEST_METHOD(TestParseFunctionDefinition)
{
    auto ast = simpl::parse("def add(a, b) { return a + b; }");
    Assert::AreEqual(size_t{ 1 }, ast.size());
    const auto& stmt = ast[0];
    
    auto func = dynamic_cast<simpl::func_definition_statement*>(stmt.get());
    Assert::IsNotNull(func);
    Assert::AreEqual(std::string("add"), func->name());
}
```

4. Build the project and run your test to verify it works
5. **Bonus Challenge:** Add additional tests for:
   - Functions with no parameters: `def foo() { return 1; }`
   - Functions with multiple statements in the body
   - Nested function calls

6. Commit your contribution:
   ```
   git add simpl.test/simpl.parser.test.cpp
   git commit -m "Add parser test for function definitions"
   ```

### Understanding Statement Types

The parser creates different statement types for different language constructs. You can find these in `include/simpl/statement.h`:

- `let_statement` - Variable declarations
- `if_statement` - Conditional statements
- `while_statement` - While loops
- `for_statement` - For loops
- `func_definition_statement` - Function definitions
- `expr_statement` - Expression statements
- `object_definition_statement` - Object/class definitions

Each test uses `dynamic_cast` to verify that the parser created the correct statement type from the source code.

Great work! You've now contributed tests for both the tokenizer and the parser!

## Next
[Lesson 3](https://github.com/mvpete/simpl/blob/master/lessons/L3.md)

