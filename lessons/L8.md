# Lesson 8 - Functions and Closures

## Intro

Functions are the building blocks of any program. In SIMPL, functions are first-class citizens - they can be passed as arguments, returned from other functions, and stored in variables. This lesson explores SIMPL's powerful function features including closures and higher-order functions.

## Defining Functions

Basic function syntax in SIMPL:

```simpl
def function_name(param1, param2) {
    # function body
    return result;
}
```

Simple example:

```simpl
@import io

def add(a, b) {
    return a + b;
}

let result = add(5, 3);
println(result);  # 8
```

## Functions Without Return Values

Functions that don't explicitly return a value return `null`:

```simpl
def greet(name) {
    println("Hello, " + name + "!");
}

greet("World");  # Prints but returns nothing
```

## Functions with Multiple Statements

Functions can contain any number of statements:

```simpl
def calculate_stats(numbers) {
    let sum = 0;
    let count = length(numbers);
    
    for(let i = 0; i < count; i = i + 1) {
        sum = sum + numbers[i];
    }
    
    let average = sum / count;
    println("Sum: " + sum);
    println("Average: " + average);
    
    return average;
}
```

## Recursion

SIMPL supports recursive functions:

```simpl
@import io

def factorial(n) {
    if(n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

println(factorial(5));  # 120
```

Another example - Fibonacci:

```simpl
def fibonacci(n) {
    if(n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

println(fibonacci(7));  # 13
```

## Variable Scope

Variables have function-level scope:

```simpl
let global_var = "I'm global";

def my_function() {
    let local_var = "I'm local";
    println(global_var);  # Can access global
    println(local_var);   # Can access local
}

my_function();
# println(local_var);  # ERROR: local_var not accessible here
```

## Functions as Values

Functions can be stored in variables and passed around:

```simpl
def square(x) {
    return x * x;
}

# Store function in variable
let my_func = square;

# Call through variable
let result = my_func(5);  # 25
```

## Function Address Operator

Use `&` to get a function reference:

```simpl
def my_function() {
    println("Hello!");
}

# Get function address
let func_ref = &my_function;

# Can be passed to other functions or stored
```

## Higher-Order Functions

Functions that take other functions as parameters:

```simpl
@import io
@import array

def apply_to_array(arr, operation) {
    let count = length(arr);
    for(let i = 0; i < count; i = i + 1) {
        arr[i] = operation(arr[i]);
    }
}

def double(x) {
    return x * 2;
}

def square(x) {
    return x * x;
}

let numbers = new [1, 2, 3, 4, 5];

apply_to_array(numbers, &double);
println(numbers);  # [2, 4, 6, 8, 10]

apply_to_array(numbers, &square);
println(numbers);  # [4, 16, 36, 64, 100]
```

## Closures and Captured Variables

Functions can capture variables from their surrounding scope:

```simpl
def make_counter() {
    let count = 0;
    
    def increment() {
        count = count + 1;
        return count;
    }
    
    return &increment;
}

let counter = make_counter();
println(counter());  # 1
println(counter());  # 2
println(counter());  # 3
```

## Function Overloading with Type Dispatch

Combine functions with multi-methods for type-based behavior:

```simpl
def process(value is number) {
    return value * 2;
}

def process(value is string) {
    return value + value;
}

println(process(5));        # 10
println(process("hello"));  # "hellohello"
```

## Exercise 8 - Understanding Functions

Explore function-related code:

1. Look at `examples/example.sl` - various function examples
2. Review `simpl.test/simpl.engine.test.cpp`:
   - `TestFunctionCall` - Function invocation
   - `TestFunctionAddress` - Function references
   - `TestFunctionReturnValue` - Return values

## Your Contribution: Function Utilities Library

Create a collection of useful utility functions!

### Task: Build a Math and String Utility Library

Create `examples/utilities.sl` with reusable utility functions:

**Requirements:**

1. **Math utilities:**
   - `max(a, b)` - Return larger of two numbers
   - `min(a, b)` - Return smaller of two numbers
   - `abs(x)` - Absolute value
   - `power(base, exp)` - Calculate power (recursive)

2. **Array utilities:**
   - `sum(array)` - Sum all numbers in array
   - `average(array)` - Calculate average
   - `find(array, value)` - Find index of value

3. **String utilities:**
   - `repeat(str, times)` - Repeat string n times
   - `starts_with(str, prefix)` - Check if string starts with prefix (bonus)

**Example skeleton:**

```simpl
@import io
@import array

# ===== Math Utilities =====

def max(a, b) {
    if(a > b) {
        return a;
    }
    return b;
}

def min(a, b) {
    if(a < b) {
        return a;
    }
    return b;
}

def abs(x) {
    if(x < 0) {
        return -x;
    }
    return x;
}

def power(base, exp) {
    if(exp == 0) {
        return 1;
    }
    if(exp == 1) {
        return base;
    }
    return base * power(base, exp - 1);
}

# ===== Array Utilities =====

def sum(arr) {
    let total = 0;
    let count = length(arr);
    for(let i = 0; i < count; i = i + 1) {
        total = total + arr[i];
    }
    return total;
}

def average(arr) {
    return sum(arr) / length(arr);
}

def find(arr, value) {
    let count = length(arr);
    for(let i = 0; i < count; i = i + 1) {
        if(arr[i] == value) {
            return i;
        }
    }
    return -1;  # Not found
}

# ===== String Utilities =====

def repeat(str, times) {
    let result = "";
    for(let i = 0; i < times; i = i + 1) {
        result = result + str;
    }
    return result;
}

# ===== Testing =====

println("=== Math Tests ===");
println("max(10, 5) = " + max(10, 5));
println("min(10, 5) = " + min(10, 5));
println("abs(-7) = " + abs(-7));
println("power(2, 8) = " + power(2, 8));

println("");
println("=== Array Tests ===");
let numbers = new [10, 20, 30, 40, 50];
println("sum([10,20,30,40,50]) = " + sum(numbers));
println("average([10,20,30,40,50]) = " + average(numbers));
println("find([10,20,30,40,50], 30) = " + find(numbers, 30));

println("");
println("=== String Tests ===");
println("repeat('Ha', 3) = " + repeat("Ha", 3));
```

**Expected Output:**
```
=== Math Tests ===
max(10, 5) = 10
min(10, 5) = 5
abs(-7) = 7
power(2, 8) = 256

=== Array Tests ===
sum([10,20,30,40,50]) = 150
average([10,20,30,40,50]) = 30
find([10,20,30,40,50], 30) = 2

=== String Tests ===
repeat('Ha', 3) = HaHaHa
```

### Testing Your Code

1. Run your program:
   ```
   simpl.repl.exe ..\examples\utilities.sl
   ```

2. Verify all functions work correctly

### Bonus Challenges

1. **Higher-order array functions:**
   ```simpl
   def map(arr, func) {
       let result = new [];
       let count = length(arr);
       for(let i = 0; i < count; i = i + 1) {
           push(result, func(arr[i]));
       }
       return result;
   }
   
   def filter(arr, predicate) {
       let result = new [];
       let count = length(arr);
       for(let i = 0; i < count; i = i + 1) {
           if(predicate(arr[i])) {
               push(result, arr[i]);
           }
       }
       return result;
   }
   ```

2. **Memoization for factorial:**
   ```simpl
   let memo = new [];
   
   def factorial_memo(n) {
       if(n <= 1) {
           return 1;
       }
       # Check memo (simplified - would need proper cache)
       return n * factorial_memo(n - 1);
   }
   ```

3. **Function composition:**
   ```simpl
   def compose(f, g) {
       def composed(x) {
           return f(g(x));
       }
       return &composed;
   }
   ```

4. **Add tests:**
   ```cpp
   TEST_METHOD(TestRecursiveFunction)
   {
       auto ast = simpl::parse(
           "def fact(n) { "
           "    if(n <= 1) { return 1; } "
           "    return n * fact(n - 1); "
           "} "
           "let result = fact(5); "
           "assert(result);"
       );
       
       bool called = false;
       check = [&](const simpl::value_t& v) {
           called = true;
           Assert::AreEqual(120.0, std::get<simpl::number>(v));
       };
       
       simpl::evaluate(ast, e);
       Assert::IsTrue(called);
   }
   ```

### Commit Your Work

```bash
git add examples/utilities.sl
git commit -m "Add utility functions library demonstrating recursion and higher-order functions"
```

## Function Best Practices

✅ **Single Responsibility:** Each function should do one thing well  
✅ **Descriptive Names:** Use clear, action-oriented names  
✅ **Keep it Short:** Functions should be concise and focused  
✅ **Minimize Side Effects:** Prefer returning values over modifying globals  
✅ **Document Complex Logic:** Add comments for non-obvious behavior  

## Common Patterns

**Factory functions:**
```simpl
def create_player(name, level) {
    return new Player{ name=name, level=level, health=100 };
}
```

**Callback pattern:**
```simpl
def process_data(data, callback) {
    # Process data
    callback(result);
}
```

**Guard clauses:**
```simpl
def divide(a, b) {
    if(b == 0) {
        return "Error: division by zero";
    }
    return a / b;
}
```

## Key Takeaways

✅ **Functions** encapsulate reusable logic  
✅ **Recursion** allows functions to call themselves  
✅ **First-class functions** can be stored and passed around  
✅ **Higher-order functions** operate on other functions  
✅ **Closures** capture variables from outer scope  
✅ **Multi-methods** enable type-based dispatch  

Fantastic work! You're now a SIMPL function master!

## Next
[Lesson 9](https://github.com/mvpete/simpl/blob/master/lessons/L9.md)
