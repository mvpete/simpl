# Lesson 4 - Adding a New Feature (Advanced)

## Intro

Congratulations on making it this far! You've learned about the tokenizer, parser, and engine. You've written tests for each component. Now it's time to put it all together and add a completely new feature to the SIMPL language.

This is an advanced lesson that will challenge you to think about how all the pieces fit together. You'll need to make changes across multiple components to implement a new language feature from scratch.

## The Feature: Ternary Operator

Many programming languages support a ternary (conditional) operator that provides a compact way to write simple if-else expressions. The syntax is:

```
condition ? value_if_true : value_if_false
```

For example:
```javascript
let result = (x > 10) ? "big" : "small";
```

This is equivalent to:
```javascript
let result;
if (x > 10) {
    result = "big";
} else {
    result = "small";
}
```

Your mission, should you choose to accept it, is to add ternary operator support to SIMPL!

## Implementation Plan

To add the ternary operator, you'll need to modify three main components:

### 1. Tokenizer (Easy)
The tokenizer needs to recognize `?` and `:` as special tokens (they might already be recognized as operators).

**File:** `include/simpl/tokenizer.h`

**What to check:**
- Verify that `?` and `:` are tokenized as operators
- You can test this by adding a tokenizer test

### 2. Parser (Moderate)
The parser needs to recognize the ternary pattern and create a new expression type.

**Files:** 
- `include/simpl/statement.h` - Define a new `ternary_expression` class
- `include/simpl/parser.h` - Add parsing logic for the ternary operator

**What to do:**
1. Create a `ternary_expression` class that holds:
   - The condition expression
   - The true-value expression  
   - The false-value expression
2. Add parsing logic to recognize the pattern: `expression ? expression : expression`
3. Handle operator precedence (ternary is typically low precedence)

### 3. Evaluator (Moderate)
The engine needs to know how to evaluate a ternary expression.

**File:** `include/simpl/evaluate.h` or related evaluation files

**What to do:**
1. Add an evaluation case for `ternary_expression`
2. Evaluate the condition
3. Based on the result, evaluate and return either the true or false expression

## Your Contribution: Start Small

This is a complex task! Here's a recommended approach:

### Step 1: Write Tests First (TDD Approach)

Before implementing anything, write tests that describe what you want:

**Tokenizer Test:**
```cpp
TEST_METHOD(TestTokenTernaryOperators)
{
    std::string text{ "x ? y : z" };
    simpl::tokenizer t{ text };
    
    auto t1 = t.next(); // x
    auto t2 = t.next(); // ?
    auto t3 = t.next(); // y
    auto t4 = t.next(); // :
    auto t5 = t.next(); // z
    
    Assert::AreEqual(simpl::token_types::identifier_token, t1.type);
    Assert::AreEqual(simpl::token_types::op, t2.type);
    Assert::AreEqual(std::string("?"), t2.to_string());
    Assert::AreEqual(simpl::token_types::op, t4.type);
    Assert::AreEqual(std::string(":"), t4.to_string());
}
```

**Parser Test:**
```cpp
TEST_METHOD(TestParseTernaryExpression)
{
    auto ast = simpl::parse("let x = 1 > 0 ? 42 : 0;");
    Assert::AreEqual(size_t{ 1 }, ast.size());
    // Add more specific checks once you define ternary_expression
}
```

**Engine Test:**
```cpp
TEST_METHOD(TestTernaryOperatorTrue)
{
    bool called = false;
    check = [&](const simpl::value_t& v)
    {
        called = true;
        Assert::IsTrue(std::holds_alternative<simpl::number>(v));
        Assert::AreEqual(42.0, std::get<simpl::number>(v));
    };
    
    auto ast = simpl::parse("let result = 1 > 0 ? 42 : 0; assert(result);");
    simpl::evaluate(ast, e);
    Assert::IsTrue(called);
}

TEST_METHOD(TestTernaryOperatorFalse)
{
    bool called = false;
    check = [&](const simpl::value_t& v)
    {
        called = true;
        Assert::IsTrue(std::holds_alternative<simpl::number>(v));
        Assert::AreEqual(0.0, std::get<simpl::number>(v));
    };
    
    auto ast = simpl::parse("let result = 1 < 0 ? 42 : 0; assert(result);");
    simpl::evaluate(ast, e);
    Assert::IsTrue(called);
}
```

### Step 2: Study Existing Code

Before implementing, study how existing operators and expressions work:
- Look at how `if_statement` is implemented
- Look at how binary operators (like `+`, `-`) are parsed
- Look at how expressions are evaluated in the engine

### Step 3: Implement in Stages

1. **Get tokenization working** - Verify `?` and `:` are recognized
2. **Implement the AST node** - Create `ternary_expression` class
3. **Implement parsing** - Add logic to recognize and parse the pattern
4. **Implement evaluation** - Add logic to evaluate ternary expressions
5. **Test incrementally** - Run tests after each stage

### Step 4: Example Implementation Skeleton

Here's a skeleton to get you started:

**In statement.h:**
```cpp
class ternary_expression : public expression
{
    std::unique_ptr<expression> condition_;
    std::unique_ptr<expression> true_expr_;
    std::unique_ptr<expression> false_expr_;
    
public:
    ternary_expression(
        std::unique_ptr<expression> cond,
        std::unique_ptr<expression> true_expr,
        std::unique_ptr<expression> false_expr)
        : condition_(std::move(cond))
        , true_expr_(std::move(true_expr))
        , false_expr_(std::move(false_expr))
    {}
    
    const expression& condition() const { return *condition_; }
    const expression& true_expr() const { return *true_expr_; }
    const expression& false_expr() const { return *false_expr_; }
};
```

## Alternative: Simpler Feature Ideas

If the ternary operator seems too complex, here are simpler features to try:

1. **Modulo Operator (`%`)** - Add support for `x % y`
2. **Power Operator (`**`)** - Add support for `x ** y` (exponentiation)
3. **String Methods** - Add built-in functions like `len(string)` or `upper(string)`
4. **Logical NOT (`!`)** - Add support for `!condition`

## Commit Your Work

Once you have a working implementation:

```bash
git add include/simpl/tokenizer.h include/simpl/statement.h include/simpl/parser.h include/simpl/evaluate.h simpl.test/*.cpp
git commit -m "Add ternary operator support to SIMPL"
```

## Congratulations!

If you've made it through all four lessons and completed the exercises, you've:
- ✅ Created your first SIMPL program
- ✅ Written tests for the tokenizer
- ✅ Written tests for the parser  
- ✅ Written tests for the engine
- ✅ (Optionally) Added a new language feature

You now understand how programming languages work from the inside! You've gained practical experience with:
- Lexical analysis (tokenization)
- Syntactic analysis (parsing)
- Abstract Syntax Trees
- Interpretation and evaluation
- Test-driven development
- Modern C++ programming

## What's Next?

- Explore the SIMPL codebase more deeply
- Add more features to the language
- Improve error messages and diagnostics
- Add more built-in functions and libraries
- Contribute to the SIMPL project on GitHub!

You've mastered the fundamentals! Ready to explore SIMPL's object-oriented features?

## Next
[Lesson 5](https://github.com/mvpete/simpl/blob/master/lessons/L5.md) - Objects and Inheritance

## Further Reading

- [Crafting Interpreters](https://craftinginterpreters.com/) - An excellent book on implementing interpreters
- [Let's Build a Simple Interpreter](https://ruslanspivak.com/lsbasi-part1/) - A comprehensive tutorial series
- [ChaiScript](https://github.com/ChaiScript/ChaiScript) - Another embedded scripting language for C++
