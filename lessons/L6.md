# Lesson 6 - Multiple Dispatch (Multi-Methods)

## Intro

You've learned about objects and inheritance. Now we're going to explore one of SIMPL's most powerful features: **multiple dispatch**, also known as **multi-methods**.

Multiple dispatch is a feature where a function call is resolved based on the runtime types of **multiple** arguments (not just one, like in traditional object-oriented languages). This allows you to write functions that behave differently depending on the types of all their parameters.

## Why Multiple Dispatch?

In traditional OOP languages (like C++ or Java), method dispatch is based on the type of a single object (usually `this`). With multiple dispatch, you can dispatch based on **all** parameters.

**Example scenario:** You're writing a game with collision detection. You want different behavior when:
- An asteroid hits another asteroid
- An asteroid hits a spaceship
- A spaceship hits an asteroid
- A spaceship hits a spaceship

Multiple dispatch makes this elegant and maintainable!

## Defining Multi-Methods

In SIMPL, you define multiple versions of the same function with type constraints using the `is` keyword:

```simpl
def greet(person is string) {
    println("Hello, " + person + "!");
}

def greet(person is number) {
    println("Hello, person #" + person);
}
```

When you call `greet("Alice")`, SIMPL dispatches to the first version. When you call `greet(42)`, it dispatches to the second version.

## Multiple Parameters

The real power comes when you have multiple parameters:

```simpl
def combine(a is string, b is string) {
    println("Concatenating: " + a + b);
}

def combine(a is number, b is number) {
    println("Adding: " + (a + b));
}

def combine(a is string, b is number) {
    println("Mixed: " + a + " and " + b);
}

combine("hello", "world");  # Calls first version
combine(5, 10);             # Calls second version
combine("count", 42);       # Calls third version
```

## Object Type Dispatch

This becomes even more powerful with custom object types:

```simpl
object Animal {}
object Dog inherits Animal {}
object Cat inherits Animal {}

def interact(a is Dog, b is Dog) {
    println("Dogs playing together");
}

def interact(a is Dog, b is Cat) {
    println("Dog chasing cat");
}

def interact(a is Cat, b is Dog) {
    println("Cat running from dog");
}

def interact(a is Cat, b is Cat) {
    println("Cats ignoring each other");
}

let dog1 = new Dog{};
let cat1 = new Cat{};

interact(dog1, cat1);  # "Dog chasing cat"
interact(cat1, dog1);  # "Cat running from dog"
```

## Real-World Example: Space Game Collisions

Here's the collision detection example from the README:

```simpl
@import io

object SpaceObject {}
object Asteroid inherits SpaceObject {}
object Spaceship inherits SpaceObject {}

# Define collision behavior for every combination
def collide_with(a is Asteroid, b is Asteroid) {
    println("Asteroids collide: Both destroyed!");
}

def collide_with(a is Asteroid, b is Spaceship) {
    println("Asteroid hits spaceship: Spaceship damaged!");
}

def collide_with(a is Spaceship, b is Asteroid) {
    println("Spaceship hits asteroid: Asteroid destroyed!");
}

def collide_with(a is Spaceship, b is Spaceship) {
    println("Spaceships collide: Both damaged!");
}

# Generic collision function
def collide(a is SpaceObject, b is SpaceObject) {
    collide_with(a, b);  # Dispatches to specific version
}

# Test all collision types
collide(new Asteroid{}, new Spaceship{});
collide(new Asteroid{}, new Asteroid{});
collide(new Spaceship{}, new Asteroid{});
collide(new Spaceship{}, new Spaceship{});
```

## How It Works

When you call a multi-method:

1. **Runtime type check:** SIMPL examines the actual types of all arguments
2. **Best match selection:** It finds the most specific matching function signature
3. **Dispatch:** The matching function is called

If no exact match is found and no compatible match exists, you'll get a runtime error.

## Using Array Explosion with Multi-Methods

You can combine array explosion (`...`) with multi-methods for dynamic dispatch:

```simpl
def process(a is string, b is number) {
    println("Processing: " + a + " with " + b);
}

let data = new ["hello", 42];
process(data...);  # Unpacks array and dispatches correctly
```

## Exercise 6 - Understanding Multi-Methods

Explore how multi-methods work in the codebase:

1. Review `examples/example.sl` - see the multi-method examples
2. Look at `simpl.test/simpl.engine.test.cpp` - find tests related to type dispatch
3. Examine how the engine resolves function calls based on types

## Your Contribution: Implement a Combat System

Create a sophisticated combat system using multiple dispatch!

### Task: Build a Type-Based Combat System

Create a new file called `examples/combat.sl` that implements a combat system with multi-methods:

**Requirements:**

1. Define at least 3 character types (use your characters from Lesson 5 or create new ones)
2. Implement `attack` multi-methods for each character combination
3. Each combination should have unique behavior
4. Create instances and demonstrate all attack combinations

**Example skeleton:**

```simpl
@import io

# Define character types
object Character {}
object Warrior inherits Character {}
object Mage inherits Character {}
object Rogue inherits Character {}

# Define attack behaviors for different combinations
def attack(attacker is Warrior, defender is Warrior) {
    println("Warrior vs Warrior: Sword clash!");
}

def attack(attacker is Warrior, defender is Mage) {
    println("Warrior vs Mage: Warrior charges, Mage retreats!");
}

def attack(attacker is Warrior, defender is Rogue) {
    println("Warrior vs Rogue: Rogue dodges the heavy attack!");
}

def attack(attacker is Mage, defender is Warrior) {
    println("Mage vs Warrior: Magic missile hits armor!");
}

def attack(attacker is Mage, defender is Mage) {
    println("Mage vs Mage: Magical duel!");
}

def attack(attacker is Mage, defender is Rogue) {
    println("Mage vs Rogue: Fireball! Rogue takes damage!");
}

# Add Rogue attack methods here...

# Create characters
let warrior = new Warrior{};
let mage = new Mage{};
let rogue = new Rogue{};

# Test all combinations
println("=== Combat Tests ===");
attack(warrior, mage);
attack(mage, warrior);
attack(rogue, warrior);
# Add more tests...
```

**Expected Output:**
```
=== Combat Tests ===
Warrior vs Mage: Warrior charges, Mage retreats!
Mage vs Warrior: Magic missile hits armor!
Rogue vs Warrior: Backstab for extra damage!
...
```

### Testing Your Code

1. Run your program:
   ```
   simpl.repl.exe ..\examples\combat.sl
   ```

2. Verify that:
   - All 9 combinations are implemented (3×3 = 9 methods)
   - Each combination produces unique output
   - The correct method is called for each pairing

### Bonus Challenges

1. **Add damage calculation:**
   - Each attack method modifies character health
   - Print remaining health after each attack

2. **Add a fourth character type:**
   - This requires 16 total methods (4×4)
   - Implement all combinations

3. **Create a test:**
   - Add a test in `simpl.test/simpl.engine.test.cpp`
   - Test that multi-method dispatch works correctly
   - Example test skeleton:

```cpp
TEST_METHOD(TestMultiMethodDispatch)
{
    // Register a multi-method for testing
    e.machine().reg_fn("test_dispatch", [](const std::string& type1, const std::string& type2) {
        return type1 + " vs " + type2;
    });
    
    auto ast = simpl::parse(
        "object TypeA {} "
        "object TypeB {} "
        "def fight(a is TypeA, b is TypeB) { return \"A vs B\"; } "
        "let result = fight(new TypeA{}, new TypeB{}); "
        "assert(result);"
    );
    
    bool called = false;
    check = [&](const simpl::value_t& v) {
        called = true;
        Assert::AreEqual(std::string("A vs B"), std::get<std::string>(v));
    };
    
    simpl::evaluate(ast, e);
    Assert::IsTrue(called);
}
```

### Commit Your Work

```bash
git add examples/combat.sl
git commit -m "Add combat system example demonstrating multiple dispatch"
```

## Understanding Multi-Method Resolution

The engine uses a type matching algorithm:

1. **Type Registry:** All object types are registered when defined
2. **Function Signatures:** Each multi-method version stores its parameter types
3. **Best Match:** When called, the engine finds the most specific matching signature
4. **Inheritance:** Child types match parent type parameters (covariance)

## Design Patterns with Multi-Methods

Multiple dispatch enables several powerful patterns:

**Visitor Pattern (simplified):**
```simpl
def visit(visitor is Logger, element is Button) {
    println("Logging button click");
}

def visit(visitor is Renderer, element is Button) {
    println("Rendering button");
}
```

**Double Dispatch for Collision:**
```simpl
def handle(shape1 is Circle, shape2 is Rectangle) { ... }
def handle(shape1 is Rectangle, shape2 is Circle) { ... }
```

**Event Handling:**
```simpl
def on_event(handler is InputHandler, event is KeyPress) { ... }
def on_event(handler is InputHandler, event is MouseClick) { ... }
```

## When to Use Multi-Methods

✅ **Good use cases:**
- Collision detection (object × object interactions)
- Combat systems (attacker × defender)
- Event handling (handler × event type)
- Visitor patterns
- Binary operations on different types

❌ **Avoid when:**
- Simple single-parameter dispatch (use regular inheritance)
- Too many type combinations (becomes hard to maintain)
- Types change frequently (must update all combinations)

## Key Takeaways

✅ **Multiple dispatch** selects functions based on multiple argument types  
✅ **Multi-methods** are defined with `is TypeName` type constraints  
✅ **Runtime resolution** finds the best matching signature  
✅ **Inheritance works** - child types match parent type parameters  
✅ **Powerful pattern** for modeling complex interactions  
✅ **Unique to SIMPL** - not available in most mainstream languages  

Congratulations! You've mastered one of SIMPL's most advanced and distinctive features!

Ready to work with collections and data structures?

## Next
[Lesson 7](https://github.com/mvpete/simpl/blob/master/lessons/L7.md) - Arrays and Collections

## Further Reading

- [Multiple Dispatch in Julia](https://docs.julialang.org/en/v1/manual/methods/) - Another language with multiple dispatch
- [Visitor Pattern](https://en.wikipedia.org/wiki/Visitor_pattern) - Related design pattern
- [Method Overloading vs Multiple Dispatch](https://en.wikipedia.org/wiki/Multiple_dispatch) - Understanding the difference
