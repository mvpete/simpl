# Lesson 10 - Building a Complete Application

## Intro

Congratulations on making it to the final lesson! You've learned the fundamentals of SIMPL, from tokenization to libraries. Now it's time to put everything together and build a complete, real-world application.

This lesson will guide you through:
- Planning a SIMPL application
- Structuring your code
- Combining all SIMPL features
- Building a working game or utility
- Best practices for larger projects

## Application Design Principles

### Start with Requirements

Before writing code, define what your application should do:

1. **What problem does it solve?**
2. **Who are the users?**
3. **What are the core features?**
4. **What data needs to be managed?**

### Structure Your Code

Organize code into logical sections:

```simpl
# ===== Configuration =====
# Constants and settings

# ===== Object Definitions =====
# Custom types

# ===== Utility Functions =====
# Helper functions

# ===== Core Logic =====
# Main application logic

# ===== Main Program =====
# Entry point and execution
```

## Example Application: Text-Based RPG

Let's build a complete text-based RPG (Role-Playing Game)!

### Features:
- Character creation with classes
- Turn-based combat system
- Inventory management
- Multiple enemy types
- Multiple dispatch for combat

### Full Implementation:

Create `examples/rpg_game.sl`:

```simpl
@import io
@import array

println("=================================");
println("   SIMPL RPG - Epic Adventure");
println("=================================");
println("");

# ===== Configuration =====

object GameConfig {
    player_starting_health = 100;
    player_starting_mana = 50;
    enemy_spawn_count = 3;
}

let config = new GameConfig{};

# ===== Character Objects =====

object Character {
    name = "Unknown";
    health = 100;
    max_health = 100;
    level = 1;
    is_alive = true;
}

object Player inherits Character {
    player_class = "Warrior";
    mana = 50;
    max_mana = 50;
    inventory = new [];
    gold = 0;
}

object Enemy inherits Character {
    enemy_type = "Goblin";
    gold_reward = 10;
    xp_reward = 25;
}

# Enemy Types
object Goblin inherits Enemy {
    name = "Goblin";
    health = 30;
    max_health = 30;
    gold_reward = 5;
}

object Orc inherits Enemy {
    name = "Orc";
    health = 60;
    max_health = 60;
    gold_reward = 15;
}

object Dragon inherits Enemy {
    name = "Dragon";
    health = 150;
    max_health = 150;
    gold_reward = 100;
}

# ===== Utility Functions =====

def show_stats(character) {
    println("--- " + character.name + " ---");
    println("Health: " + character.health + "/" + character.max_health);
    if(character.mana) {
        println("Mana: " + character.mana + "/" + character.max_mana);
    }
    println("Level: " + character.level);
}

def is_alive(character) {
    return character.health > 0;
}

def take_damage(character, amount) {
    character.health = character.health - amount;
    if(character.health < 0) {
        character.health = 0;
        character.is_alive = false;
    }
}

def heal(character, amount) {
    character.health = character.health + amount;
    if(character.health > character.max_health) {
        character.health = character.max_health;
    }
}

# ===== Combat System with Multiple Dispatch =====

def attack(attacker is Player, defender is Goblin) {
    let damage = 15;
    println(attacker.name + " attacks " + defender.name + "!");
    println("Deals " + damage + " damage!");
    take_damage(defender, damage);
}

def attack(attacker is Player, defender is Orc) {
    let damage = 20;
    println(attacker.name + " attacks " + defender.name + "!");
    println("Deals " + damage + " damage!");
    take_damage(defender, damage);
}

def attack(attacker is Player, defender is Dragon) {
    let damage = 25;
    println(attacker.name + " attacks " + defender.name + "!");
    println("Dragon's scales resist some damage!");
    println("Deals " + damage + " damage!");
    take_damage(defender, damage);
}

def attack(attacker is Goblin, defender is Player) {
    let damage = 8;
    println(attacker.name + " attacks " + defender.name + "!");
    println("Deals " + damage + " damage!");
    take_damage(defender, damage);
}

def attack(attacker is Orc, defender is Player) {
    let damage = 15;
    println(attacker.name + " attacks " + defender.name + "!");
    println("Deals " + damage + " damage!");
    take_damage(defender, damage);
}

def attack(attacker is Dragon, defender is Player) {
    let damage = 30;
    println(attacker.name + " breathes fire!");
    println("Deals " + damage + " damage!");
    take_damage(defender, damage);
}

# ===== Inventory System =====

object Item {
    name = "Item";
    description = "A basic item";
    value = 1;
}

object Potion inherits Item {
    name = "Health Potion";
    description = "Restores 30 health";
    value = 10;
    heal_amount = 30;
}

def add_item(player, item) {
    push(player.inventory, item);
    println("Added " + item.name + " to inventory");
}

def use_potion(player) {
    let count = length(player.inventory);
    for(let i = 0; i < count; i = i + 1) {
        let item = player.inventory[i];
        if(item.heal_amount) {
            heal(player, item.heal_amount);
            println("Used " + item.name + "!");
            println("Restored " + item.heal_amount + " health");
            # Remove item (simplified - just break)
            return true;
        }
    }
    println("No potions available!");
    return false;
}

# ===== Game Logic =====

def create_player(name) {
    println("");
    println("Creating character: " + name);
    
    let player = new Player{
        name = name,
        health = config.player_starting_health,
        max_health = config.player_starting_health,
        mana = config.player_starting_mana,
        max_mana = config.player_starting_mana,
        inventory = new [],
        gold = 50
    };
    
    # Give starting items
    add_item(player, new Potion{});
    add_item(player, new Potion{});
    
    return player;
}

def create_random_enemy(level) {
    # Simple random selection
    let type = level % 3;
    
    if(type == 0) {
        return new Goblin{};
    }
    if(type == 1) {
        return new Orc{};
    }
    return new Dragon{};
}

def combat_round(player, enemy) {
    println("");
    println("=== Combat Round ===");
    
    # Player attacks
    attack(player, enemy);
    
    if(!is_alive(enemy)) {
        println(enemy.name + " defeated!");
        player.gold = player.gold + enemy.gold_reward;
        println("Gained " + enemy.gold_reward + " gold!");
        return true;
    }
    
    # Enemy attacks
    println("");
    attack(enemy, player);
    
    if(!is_alive(player)) {
        println("You have been defeated!");
        return false;
    }
    
    println("");
    show_stats(player);
    show_stats(enemy);
    
    return false;  # Continue combat
}

# ===== Main Game Loop =====

def start_game() {
    println("");
    println("Welcome to SIMPL RPG!");
    println("");
    
    # Create player
    let player = create_player("Hero");
    
    println("");
    show_stats(player);
    
    # Game loop
    let battles_won = 0;
    let max_battles = 3;
    
    for(let battle = 0; battle < max_battles; battle = battle + 1) {
        println("");
        println("=================================");
        println("Battle " + (battle + 1) + " of " + max_battles);
        println("=================================");
        
        let enemy = create_random_enemy(battle);
        println("A " + enemy.name + " appears!");
        
        show_stats(enemy);
        
        # Combat loop
        let combat_active = true;
        let rounds = 0;
        let max_rounds = 10;
        
        while(combat_active && rounds < max_rounds) {
            rounds = rounds + 1;
            
            let result = combat_round(player, enemy);
            
            if(result) {
                # Enemy defeated
                battles_won = battles_won + 1;
                combat_active = false;
                
                # Heal player between battles
                heal(player, 20);
                println("You rest and recover 20 health");
            }
            
            if(!is_alive(player)) {
                # Player defeated
                combat_active = false;
            }
        }
        
        if(!is_alive(player)) {
            break;
        }
    }
    
    # Game over
    println("");
    println("=================================");
    println("         Game Over!");
    println("=================================");
    println("Battles won: " + battles_won + "/" + max_battles);
    println("Gold earned: " + player.gold);
    
    if(battles_won == max_battles) {
        println("");
        println("Victory! You are a true hero!");
    }
}

# ===== Start the Game =====

start_game();

println("");
println("Thanks for playing SIMPL RPG!");
```

### Testing the Game

Run your game:
```
simpl.repl.exe ..\examples\rpg_game.sl
```

Watch the combat unfold!

## Your Contribution: Build Your Own Application

Now create your own complete application!

### Project Ideas:

**1. Task Manager**
- Add/remove/list tasks
- Mark tasks complete
- Priority levels
- Due dates

**2. Simple Calculator**
- Basic operations
- Expression evaluation
- History of calculations
- Memory functions

**3. Adventure Game**
- Room navigation
- Inventory system
- Puzzles
- Multiple endings

**4. Quiz Game**
- Multiple choice questions
- Score tracking
- Categories
- High scores

**5. Database Simulator**
- Store records
- Search/filter
- Update records
- Statistics

### Requirements:

Your application should:

1. **Use at least 5 SIMPL features:**
   - âœ… Objects and inheritance
   - âœ… Multiple dispatch
   - âœ… Arrays
   - âœ… Functions
   - âœ… Libraries (@import)

2. **Have clear structure:**
   - Configuration section
   - Object definitions
   - Utility functions
   - Core logic
   - Main execution

3. **Be interactive or demonstrative:**
   - Either accept user input
   - Or demonstrate functionality automatically

4. **Include error handling:**
   - Check for invalid inputs
   - Handle edge cases
   - Provide helpful messages

### Template Structure:

```simpl
@import io
@import array

println("=== My Application ===");

# ===== Configuration =====
# Constants and settings here

# ===== Object Definitions =====
# Define your custom types

# ===== Utility Functions =====
# Helper functions

# ===== Core Logic =====
# Main application functions

# ===== Main Program =====
def main() {
    # Your application logic
}

main();
```

### Commit Your Work

```bash
git add examples/your_app.sl
git commit -m "Add complete [application name] demonstrating all SIMPL features"
```

## Testing and Debugging

### Common Issues:

**Problem:** "Undefined variable"
- **Solution:** Check variable scope, ensure it's defined before use

**Problem:** "Function not found"
- **Solution:** Check function name, ensure @import statements are present

**Problem:** "Type mismatch in multi-method"
- **Solution:** Check object types match expected multi-method signatures

### Debugging Strategies:

1. **Add print statements:**
   ```simpl
   println("Debug: variable = " + variable);
   ```

2. **Test incrementally:**
   - Build one feature at a time
   - Test after each addition

3. **Simplify:**
   - Comment out complex code
   - Test with simpler inputs

## Best Practices for Larger Projects

### Code Organization

âœ… **Group related functions** together  
âœ… **Use consistent naming** conventions  
âœ… **Add comments** for complex logic  
âœ… **Keep functions focused** on single tasks  
âœ… **Validate inputs** early  

### Performance Tips

âœ… **Minimize loops** when possible  
âœ… **Cache computed values** to avoid recalculation  
âœ… **Use appropriate data structures** (arrays vs objects)  
âœ… **Avoid deep recursion** for large inputs  

### Maintainability

âœ… **Write self-documenting code** with clear names  
âœ… **Keep magic numbers** in configuration objects  
âœ… **Document assumptions** with comments  
âœ… **Test edge cases** thoroughly  

## Congratulations! ğŸ‰

You've completed all 10 SIMPL lessons! You've learned:

### Core Language (L0-L4):
- âœ… **L0:** Getting started with SIMPL
- âœ… **L1:** Tokenization and lexical analysis
- âœ… **L2:** Parsing and AST construction
- âœ… **L3:** Engine and evaluation
- âœ… **L4:** Adding new language features

### Advanced Features (L5-L9):
- âœ… **L5:** Objects and inheritance
- âœ… **L6:** Multiple dispatch (multi-methods)
- âœ… **L7:** Arrays and collections
- âœ… **L8:** Functions and closures
- âœ… **L9:** Libraries and modules

### Application Development (L10):
- âœ… **L10:** Building complete applications

## What's Next?

### Continue Learning:
- Study the SIMPL source code in depth
- Read "Crafting Interpreters" by Robert Nystrom
- Explore other interpreted languages (Lua, Python)
- Learn about JIT compilation and optimization

### Contribute to SIMPL:
- Fix bugs and issues
- Add new language features
- Improve documentation
- Create more example programs
- Help other learners

### Build Projects:
- Create a SIMPL standard library
- Build domain-specific applications
- Embed SIMPL in your C++ projects
- Share your creations with the community

### Share Your Knowledge:
- Write blog posts about your journey
- Create video tutorials
- Mentor new SIMPL learners
- Present at meetups or conferences

## Final Thoughts

You started as a beginner exploring a simple "hello world" program. Now you understand:

- How programming languages are implemented
- Tokenization, parsing, and evaluation
- Object-oriented programming concepts
- Advanced features like multiple dispatch
- How to build complete applications

**This knowledge transfers to other languages!** The concepts you've learned apply to:
- Interpreters and compilers
- Language design
- Type systems
- Runtime environments
- Software architecture

Keep coding, keep learning, and keep building amazing things!

Ready to give back to the SIMPL community?

## Next
[Lesson 11](https://github.com/mvpete/simpl/blob/master/lessons/L11.md) - Contributing to SIMPL and the Lessons

## Resources

- **SIMPL Repository:** [github.com/mvpete/simpl](https://github.com/mvpete/simpl)
- **Crafting Interpreters:** [craftinginterpreters.com](https://craftinginterpreters.com/)
- **Let's Build a Simple Interpreter:** [ruslanspivak.com/lsbasi-part1](https://ruslanspivak.com/lsbasi-part1/)
- **ChaiScript:** [github.com/ChaiScript/ChaiScript](https://github.com/ChaiScript/ChaiScript)

---

**Thank you for taking this journey through SIMPL!** 

**You are now a SIMPL developer! ğŸš€**
