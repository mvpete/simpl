# Lesson 1 - Anatomy { Tokenizer }


## Intro 
Have you ever wondered how the text you type in your editor (Visual Studio, VS Code, Vi, ...) turns into something that makes the lights blink?

![Computer Problems - XKCD](https://imgs.xkcd.com/comics/computer_problems.png)

There's a lot that goes into a programming language. You've got the grammar of the language, the rules of the 
language, then the platform on which the platform runs and executes. 

I wanted SIMPL to be just that, simple. I wanted it to exemplify the standard division of responsibility that
they teach about in the compiler books. Lofty goal. Here's an illustration of what I mean, typically with a programming
language the pipeline is basically like this:

The code (a character string) => Lexer (Tokenizer) => Parser => AST => Output

We're going to start with the tokenizer.

## The Tokenizer  

The tokenizer is the first step in the pipeline. Its responsibility is to chop up that long string of characters,
otherwise known as your program, into chunks known as tokens. The character '+' (decimal 43) is just a '+', it has
really no meaning. The tokenizer assigns the first bit of meaning to the otherwise meaningless string of characters.
The tokenizer iterates over the string, looking at each character, and scanning forward to chunk the string into
tokens. 

For instance the following string `"foo + bar"`, could tokenize into:

`{ type: identifer, text: "foo" }{ type: operator, text: "+" }{ type: identifer, text: "bar" }`

You'll notice that the whitespace isn't tokenized, this is because SIMPL ignores whitespace, thus the tokenizer consumes it. You'll find the code for the tokenizer in `simpl/tokenizer.h`.

In SIMPL, a token has a type, along with a pointer to the begining and end of the characters in that token. The tokenizer's
single responsibility is to tokenize, it doesn't know anything about the rules of the language, other than the tokens. Its output is just a string of tokens. Since the tokenizer is scanning the characters, it's an ideal place to track positioning in the file.

Don't let the templates scare you, this tokenizer is easy. It's two basic calls are 
`peek` and `next`. They both basically do the same thing, except `peek` scans ahead
without advancing the tokenizer down the string. This allows the consumer of the tokenizer, (spoiler: The Parser) to look ahead a token and evaluate what it wants to do.

Each call to `peek` starts iterating the string looking for signals i.e. digits, characters, whitespace, operators, etc.. Once it hits one of these indicators, it trys to move along until it's no longer in that token type. For instance, when it sees a space, it will keep scanning until the character isn't a space. This indicates the end of a whitespace token. `peek` stores the token, and each consequetive call will return that token. At some point, `next` will be called, which will clear the token and allow `peek` to scan forward again.


**Side note:** 
A good exercise to warm up to writing
the components of a programming language is a simple mathematic expression solver. Something that can basically
solve 1 + 2 => 3. A calculator really. This little exercise will help to build a tokenizer as you go about recogizing
the tokens in the equation.

## Exercise - Testing the tokenizer

Review the code in the file `simpl.test/simpl.tokenizer.test.cpp`.

// TODO:
- breakpoints, stepping through, example test.